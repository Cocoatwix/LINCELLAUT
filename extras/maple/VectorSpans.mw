<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="2021" minor="2"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="false" autoexpanding_sections="true" UserProfileName="Maple Default Profile" NumericFormat-ApplyInteger="true" NumericFormat-ApplyRational="true" NumericFormat-ApplyExponent="false" editable="true">
</View-Properties>
<MapleNet-Properties prettyprint="3" warnlevel="3" compactdisplay="false" preplot="" helpbrowser="standard" displayprecision="-1" echo="1" scientificx="true" unitattributes="&quot;fontweight&quot; = &quot;bold&quot;" imaginaryunit="I" longdelim="true" elisiontermsthreshold="10000" elisiondigitsafter="100" elisiondigitsbefore="100" plotdevice="inline" errorbreak="1" plotoptions="" plotdriver="opengl" quiet="false" elisiontermsbefore="100" elisiontermsafter="100" historytimestamp="false" screenwidth="79" indentamount="4" plotoutput="terminal" screenpixelheight="1600" rtablesize="[10, 10]" useclientjvm="true" format="worksheet" labelwidth="20" postplot="" typesetting="extended" ansi="false" ansicolor="[]" elisiondigitsthreshold="10000" showassumed="1" ansilprint="false" trailingsemicolon="true" errorcursor="false" labelling="true" screenheight="25" prompt="&gt; " verboseproc="1" latexwidth="8.0" ShowLabels="true"/>
<Styles>
<Font name="Heading 1" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 2" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="16" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[144,144,144]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[40,120,40]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[120,0,14]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[175,0,175]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="true"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="2" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.3" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 1" alignment="left" bullet="numeric" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="newline" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="alphabetic" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 3" alignment="left" bullet="roman" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 4" alignment="left" bullet="ALPHABETIC" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 5" alignment="left" bullet="ROMAN" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Annotation Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="dot" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="indent" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="dash" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Author" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="8" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
</Styles>
<Startup-Code startupcode=""/>
<Metadata-table>
    <Metadata-category name="&lt;default&gt;"/>
    <Metadata-tag id="0" category="&lt;default&gt;" name="Document Properties">
        <Metadata-attribute name="Keywords" value="&lt;default&gt;"/>
        <Metadata-attribute name="Item List" value="true"/>
        <Metadata-attribute name="Title" value="&lt;default&gt;"/>
        <Metadata-attribute name="Author" value="&lt;default&gt;"/>
        <Metadata-attribute name="Subject" value="&lt;default&gt;"/>
    </Metadata-tag>
</Metadata-table>
<Task-table>
    <Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/><CodeEditor-ExecGroup view="presentation" labelreference="L270" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="constants" expanded="true" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">with (LinearAlgebra[Modular]):

Equal := LinearAlgebra[Equal]:
RowDimension := LinearAlgebra[RowDimension]:

zeroVector := Vector([0, 0, 0]):
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group hide-input="false" labelreference="L1" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group labelreference="L182" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" labelreference="L234" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="proc additive_order" expanded="false" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">additive_order := proc(modulus::integer, vect::Vector)::integer;
    description &quot;Returns the additive order of the given vector under the given modulus.&quot;;
    local count, tempVect;
    global zeroVector;

    count := 0;

    do
        count += 1;
        tempVect := count*vect mod modulus;
    until (Equal(tempVect, zeroVector));
    return count;
end proc:
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group labelreference="L183" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" labelreference="L238" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="proc mod_span" expanded="false" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">mod_span := proc(modulus::integer, gens::set(Vector))::set(Vector);
    description &quot;Returns a set representing the span of the given set of vectors under the given modulus.&quot;;
    local i, span, coeffis, zeroCoeffis, tempVect, tempVect2, isNew;
    global zeroVector;

    #Preventing the empty set from causing issues
    if (gens = {}) then
        return {zeroVector};
    fi;
    
    coeffis := [seq(0, 1..numelems(gens))];
    zeroCoeffis := [seq(0, 1..numelems(gens))];
    span := {};

    do
        #Increment coefficients for forming our linear combination
        for i from 1 to numelems(coeffis) do
            if (coeffis[i] + 1 = modulus) then
                coeffis := subsop(i=0, coeffis);
            else
                coeffis := subsop(i=coeffis[i]+1, coeffis);
                break;
            fi;
        od;

        #Calculate next vector to add to span
        tempVect := Vector(RowDimension(gens[1]));
        for i from 1 to numelems(coeffis) do
            tempVect += coeffis[i]*gens[i];
        od;

        tempVect mod= modulus;

        #Check to see if our vector is already in the set
        isNew := true;
        for tempVect2 in span do
            if (Equal(tempVect, tempVect2)) then
                isNew := false;
                break;
            fi;
        od;

        if (isNew) then
            span union= {tempVect};
        fi;
    until (evalb(coeffis = zeroCoeffis));
    
    return span;
end proc:
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group hide-input="false" labelreference="L205" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" spaceabove="0" linebreak="space" rightmargin="0" linespacing="0.0" initial="0" firstindent="0" leftmargin="0" bulletsuffix="" alignment="left" bullet="none" spacebelow="0" pagebreak-before="false"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" labelreference="L243" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="proc in_span" expanded="false" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">in_span := proc(vect::Vector, span::set(Vector))::boolean;
    description &quot;Returns true if the given vector is in the given span, false otherwise.&quot;;
    local tempVect;
    
    for tempVect in span do
        if Equal(tempVect, vect) then
            return true;
        fi;
    od;

    return false;
end proc:
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group labelreference="L242" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" labelreference="L245" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="proc span_intersect" expanded="false" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">span_intersect := proc(set1::set(Vector), set2::set(Vector))::set(Vector);
    description &quot;Returns the intersection of the two given sets of vectors.&quot;;
    local tempVect, tempVect2, intersectSet;

    intersectSet := {};

    for tempVect in set1 do
        for tempVect2 in set2 do
            if (Equal(tempVect, tempVect2)) then
                intersectSet union= {tempVect};
                break;
            fi;
        od;
    od;

    return intersectSet;
end proc:
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group labelreference="L199" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" labelreference="L247" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="proc equal_span" expanded="false" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">equal_span := proc(span1::set(Vector), span2::set(Vector))::boolean;
    description &quot;Returns true if the given spans are equal, false otherwise.&quot;;
    local tempVect, tempVect2, inBoth;

    if not (numelems(span1) = numelems(span2)) then
        return false;
    else
        for tempVect in span1 do
            inBoth := false;

            #Search through span2 to ensure each vector found in span1 is there
            for tempVect2 in span2 do
                if (Equal(tempVect, tempVect2)) then
                    inBoth := true;
                    break;
                fi;
            od;

            if not (inBoth) then
                return false;
            fi;
        od;

        return true;
    fi;
end proc:
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group labelreference="L203" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" labelreference="L249" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="proc dir_set_representation" expanded="false" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">dir_set_representation := proc(modulus::integer, vect::Vector, repset::set(Vector))::set(list);
    description &quot;Returns a representation of the passed vector using the given set if possible, returns the empty set otherwise. The representation represents a polynomial expression in the following way: {[coefficient, vector], [coefficient, vector], ...}.&quot;;
    local i, coeffis, zeroCoeffis, tempVect, DIRrep;

    if (repset = {}) then
        return {};
    fi;

    coeffis := [seq(0, 1..numelems(repset))];
    zeroCoeffis := [seq(0, 1..numelems(repset))];
    DIRrep := {};

    do
        #Check to see if our current coefficients create vect
        tempVect := Vector(RowDimension(repset[1]));
        for i from 1 to numelems(coeffis) do
            tempVect += coeffis[i]*repset[i];
        od;

        tempVect mod= modulus;

        #If we found a set of coefficients that work, return them
        if (Equal(tempVect, vect)) then
           for i from 1 to numelems(coeffis) do
               DIRrep union= {[coeffis[i], repset[i]]};
           od;
           return DIRrep;
        fi;

        #Increment coeffis
        for i from 1 to numelems(coeffis) do
            if (coeffis[i] + 1 = modulus) then
                coeffis := subsop(i=0, coeffis);
            else
                coeffis := subsop(i=coeffis[i]+1, coeffis);
                break;
            fi;
        od;
    until (evalb(coeffis = zeroCoeffis));

    return {};
end proc:
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group hide-input="false" labelreference="L190" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" spaceabove="0" linebreak="space" rightmargin="0" linespacing="0.0" initial="0" firstindent="0" leftmargin="0" bulletsuffix="" alignment="left" bullet="none" spacebelow="0" pagebreak-before="false"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" labelreference="L251" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="proc minimum_multiple_in_span" expanded="false" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">minimum_multiple_in_span := proc(baseMod::integer, maxPower::integer, vect::Vector, DIspan::set(Vector))::integer;
    description &quot;Returns the first nonzero multiple of the given vector that's in the given span under the given modulus. Returns zero if the zeroth multiple is the only one in the span.&quot;;
    local power, multVect, tempVect;

    power := 0;
    while (power &lt; maxPower) do
        multVect := (baseMod^power)*vect;
        multVect mod= baseMod^maxPower;

        for tempVect in DIspan do
            if (Equal(tempVect, multVect)) then
                return baseMod^power;
            fi;
        od;

        power += 1;
    od;
    return 0;
end proc:
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group labelreference="L226" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" labelreference="L253" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="proc is_dimensionally_independent" expanded="false" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">is_dimensionally_independent := proc(modulus::integer, gens::set(Vector))::boolean;
    description &quot;Returns true if the given set of vectors is dimensionally independent, false otherwise.&quot;;
    local tempVect, zeroVect, tempSet;

    #The empty set is dimensionally independent, as is any single vector
    if (gens = {} or numelems(gens) = 1) then
        return true;
    fi;

    zeroVect := Vector(RowDimension(gens[1]));

    #Iterate through all vectors in gens, see if the DI property holds
    for tempVect in gens do
        if (Equal(zeroVect, tempVect)) then
            return false;
        fi;

        tempSet := span_intersect(mod_span(modulus, {tempVect}), mod_span(modulus, gens minus {tempVect}));
        if not ((numelems(tempSet) = 1) and (Equal(tempSet[1], zeroVect))) then
            return false;
        fi;
    od;

    return true;
end proc:
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group labelreference="L223" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" labelreference="L255" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="proc DI_split" expanded="false" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">DI_split := proc(modulus::integer, vect::Vector, repset::set(Vector))::Vector;
    description &quot;If vect is a linear combination of the vectors in repset, plus some vector that's dimensionally independent from repset, this procedure will return that dimensionally-independent part. Returns NULL if such a part doesn't exist.&quot;;
    local i, coeffis, zeroCoeffis, maybeDI;

    coeffis := [seq(0, 1..numelems(repset))];
    zeroCoeffis := [seq(0, 1..numelems(repset))];
    maybeDI := Vector(RowDimension(vect));

    #Check all linear combinations of vectors in repset, see if subtracting any creates a DI vector
    do
        Copy(modulus, vect, maybeDI);
        for i from 1 to numelems(repset) do
            maybeDI -= coeffis[i]*repset[i];
        od;

        maybeDI mod= modulus;

        if (is_dimensionally_independent(modulus, repset union {maybeDI})) then
            return maybeDI;
        fi;

        #Increment coeffis
        for i from 1 to numelems(coeffis) do
            if (coeffis[i] + 1 &gt;= modulus) then
                coeffis := subsop(i=0, coeffis);
            else
                coeffis := subsop(i=coeffis[i]+1, coeffis);
                break;
            fi;
        od;
    until (evalb(coeffis = zeroCoeffis));
    return NULL;
end proc:
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group hide-input="false" labelreference="L214" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group labelreference="L218" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" hide-input="false" labelreference="L278" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="test cases" expanded="true" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">#Some useful test cases
is_dimensionally_independent(2, {Vector([1, 0, 0])}):
equal_span(mod_span(5, {Vector([1, 0]), Vector([0, 1])}), mod_span(5, {Vector([4, 4]), Vector([3, 1])})):
minimum_multiple_in_span(3, 2, Vector([4, 0, 0]), mod_span(9, {Vector([3, 0, 0])})):

dir_set_representation(9, Vector([3, 0, 0]), {Vector([3, 0, 0])}):


DI_split(9, Vector([1, 3, 0]), {Vector([1, 0, 0])}):
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group labelreference="L256" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group labelreference="L273" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group labelreference="L222" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group><CodeEditor-ExecGroup view="presentation" hide-input="false" labelreference="L266" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="main setup" expanded="true" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">currentSet := [seq(Vector([0, 0, 0]), 1..3)]:
#currentSet := subsop(2=Vector([2, 0, 0]), currentSet):
BASEMOD := 3:
MODPOWER := 2:
</EC-CodeEditor></CodeEditor-ExecGroup><CodeEditor-ExecGroup view="presentation" hide-input="false" labelreference="L263" drawlabel="true" applyint="true" applyrational="true" display="code"><EC-CodeEditor id="main" expanded="true" visible="true" pixel-width="500" pixel-height="200" code-language="text/maple" autofit="true" wrapping="true" show-border="false" code-line-numbers="true">#Iterate through all possible combinations of vectors
print(&quot;currentSet&quot;, currentSet);
do
    newSet := {seq(currentSet[v], v=1..numelems(currentSet))};
    newSetSpan := mod_span(BASEMOD^MODPOWER, newSet);

    if not (is_dimensionally_independent(BASEMOD^MODPOWER, newSet)) then
        #First, check if there are any zero vectors in currentSet
        for tempVect in currentSet do
            if (Equal(tempVect, zeroVector)) then
                #Find zero vector in newSet and remove it
                for tempVect2 in newSet do
                    if (Equal(tempVect, tempVect2)) then
                        newSet minus= {tempVect2};
                        break;
                    fi;
                od;
            fi;
        od;
    fi;
    #There should now no longer be any zero vectors in newSet

    if not (is_dimensionally_independent(BASEMOD^MODPOWER, newSet)) then
        #Now, we'll check to see if there are any duplicate vectors in newSet
        newList := [seq(newSet[v], v=1..numelems(newSet))];
        for v1 from 1 to numelems(newList) do
            for v2 from v1+1 to numelems(newList) do
                if (Equal(newList[v1], newList[v2])) then
                    #Find duplicate in newSet, remove it
                    for tempVect in newSet do
                        if (Equal(tempVect, newList[v1])) then
                            newSet minus= {tempVect};
                            break;
                        fi;
                    od;
                fi;
            od;
        od;
    fi;
    #There should now no longer be any duplicates in newSet

    if not (is_dimensionally_independent(BASEMOD^MODPOWER, newSet)) then
        #Now, we'll make sure each vector is actually required for the span of newSet
        newList := [seq(newSet[v], v=1..numelems(newSet))];
        for v from 1 to numelems(newList) do
            subset1 := {seq(newList[x], x=1..v)};
            subset2 := {seq(newList[x], x=1..v-1)};
            if (equal_span(mod_span(BASEMOD^MODPOWER, subset1), mod_span(BASEMOD^MODPOWER, subset2))) then
                #The vector at position v isn't needed for the span of newSet. Remove it
                for tempVect in newSet do
                    if (Equal(tempVect, newList[v])) then
                        newSet minus= {tempVect};
                        break;
                    fi;
                od;
            fi;
        od;
    fi;
    #There should now no longer be any vectors which don't contribute to the span in newSet

    if not (is_dimensionally_independent(BASEMOD^MODPOWER, newSet)) then
        #Now, we'll check to see if any vector is an embedded form of some of the other vectors in newSet

        newList := [seq(newSet[v], v=1..numelems(newSet))];
        for v from 1 to numelems(newList) do
            subset2 := {seq(newList[x], x=1..v-1)};
            subsetspan := mod_span(BASEMOD^MODPOWER, subset2);

            #Check and see if the first p^c(v) has any vectors in its DIR set expression with invertible coefficients
            multInSet := minimum_multiple_in_span(BASEMOD, MODPOWER, newList[v], subsetspan);
            multVect := multInSet*newList[v];
            multVect mod= BASEMOD^MODPOWER;
            
            DIRrep := dir_set_representation(BASEMOD^MODPOWER, multVect, subset2);
            replaced := false;

            #Helpful testing info
            #print(&quot;newList[v]&quot;);
            #print(&quot;subset2&quot;, subset2, &quot;subsetspan&quot;, subsetspan);
            #print(&quot;multInSet&quot;, multInSet, &quot;DIRrep&quot;, DIRrep);

            for i from 1 to numelems(DIRrep) do
                if ((not ((DIRrep[i][1] mod BASEMOD) = 0)) and 
                (additive_order(BASEMOD^MODPOWER, DIRrep[i][2]) &gt;= additive_order(BASEMOD^MODPOWER, multInSet*newList[v]))) then
                    #Find DIRrep[i][2] in newSet, replace it with newList[v]
                    for tempVect in newSet do
                        if (Equal(tempVect, DIRrep[i][2])) then
                            newSet minus= {tempVect};
                            newSet union= {newList[v]};
                            replaced := true;
                            break;
                        fi;
                    od;

                    #We'll also remove DIRrep[i][2] from newList and replace it with 0 since we don't need it anymore
                    if (replaced) then
                        for x from 1 to numelems(newList) do
                            if (Equal(newList[x], DIRrep[i][2])) then
                                newList := subsop(x=zeroVector, newList);
                                break;
                            fi;
                        od;
                    fi;
                fi;

                if (replaced) then
                    break;
                fi;
            od;
        od;   
    fi;
    #Now, newSet should have no vectors that are &quot;between&quot; the spans of the other vectors

    if not (is_dimensionally_independent(BASEMOD^MODPOWER, newSet)) then
        newList := [seq(newSet[v], v=1..numelems(newSet))];
        for v from 1 to numelems(newSet) do
            subset2 := {seq(newList[x], x=1..v-1)};

            tempVect := DI_split(BASEMOD^MODPOWER, newList[v], subset2);
            #If there's a bit of newList[v] we can break off that's DI, swap it in to newSet
            if not (tempVect = NULL) then
                for x from 1 to numelems(newSet) do
                    if (Equal(newList[v], newSet[x])) then
                        newSet minus= {newSet[x]};
                        newSet union= {tempVect};
                        newList := subsop(v=tempVect, newList);
                        break;
                    fi;
                od;
            fi;
        od;
    fi;
    #Now, newSet shouldn't contain any vectors which would be DI if not for a linear combination of the other vectors added to it

    if not (is_dimensionally_independent(BASEMOD^MODPOWER, newSet)) then
        print(&quot;The set&quot;, newSet, &quot;is not dimensionally independent.&quot;);
        break;
    fi;

    #Making sure the span of newSet is preserved from the above operations
    newerSetSpan := mod_span(BASEMOD^MODPOWER, newSet);
    if not (equal_span(newSetSpan, newerSetSpan)) then
         print(&quot;span(newSet) changed.&quot;);
         print(currentSet);
         break;
    fi;

    #Increment through our vectors
    #This could be done more efficiently
    finishedIncrementing := false;
    secondIsIncrementing := false;
    for tempVect in currentSet do
        for elem from 1 to RowDimension(tempVect) do 
        	  #This has to be here, or else the logic doesn't work out
            if (secondIsIncrementing) then
                print(currentSet);
            fi;
            
            if (tempVect[elem] + 1 = BASEMOD^MODPOWER) then
                tempVect[elem] := 0;
            else
                tempVect[elem] += 1;
                finishedIncrementing := true;
                break;
            fi;
        od;

        
        if (finishedIncrementing) then
            break;
        fi;

        #This is to keep track of where we are in the computation
        secondIsIncrementing := true;
    od;
until (Equal(currentSet[1], zeroVector) and 
       Equal(currentSet[2], zeroVector) and
       Equal(currentSet[3], zeroVector)):
</EC-CodeEditor></CodeEditor-ExecGroup>
<Group hide-input="false" labelreference="L216" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L217" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group labelreference="L184" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">#We left off at [Vector([0, 0, 0]), Vector([5, 4, 0]), Vector([0, 0, 0])]</Text-field>
</Input>
</Group>
<Group labelreference="L279" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Worksheet>